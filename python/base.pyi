import io
from typing import Any, Iterator, List, Optional, Union

Subject = Union[NamedNode, BlankNode, Triple]
Term = Union[NamedNode, BlankNode, Literal, Triple]
GraphName = Union[NamedNode, BlankNode, DefaultGraph]

class NamedNode:
    @property
    def value(self) -> str: ...
    def __init__(self, value: str) -> None: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: NamedNode) -> bool: ...
    def __ge__(self, other: NamedNode) -> bool: ...
    def __gt__(self, other: NamedNode) -> bool: ...
    def __le__(self, other: NamedNode) -> bool: ...
    def __lt__(self, other: NamedNode) -> bool: ...
    def __ne__(self, other: NamedNode) -> bool: ...

class BlankNode:
    @property
    def value(self) -> str: ...
    def __init__(self, value: Optional[str] = None) -> None: ...
    def __eq__(self, other: BlankNode) -> bool: ...
    def __ge__(self, other: BlankNode) -> bool: ...
    def __gt__(self, other: BlankNode) -> bool: ...
    def __hash__(self: BlankNode) -> int: ...
    def __le__(self, other: BlankNode) -> bool: ...
    def __lt__(self, other: BlankNode) -> bool: ...
    def __ne__(self, other: BlankNode) -> bool: ...

class DefaultGraph:
    @property
    def value(self) -> str: ...
    def __init__(self) -> None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ge__(self, other: Any) -> bool: ...
    def __gt__(self, other: Any) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: Any) -> bool: ...
    def __lt__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...

class Literal:
    @property
    def datatype(self) -> NamedNode: ...
    @property
    def language(self) -> Union[str, None]: ...
    @property
    def value(self) -> str: ...
    def __init__(
        self,
        value: str,
        datatype: Optional[NamedNode] = None,
        language: Optional[str] = None,
    ) -> None: ...
    def __eq__(self, other: Literal) -> bool: ...
    def __ge__(self, other: Literal) -> bool: ...
    def __gt__(self, other: Literal) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: Literal) -> bool: ...
    def __lt__(self, other: Literal) -> bool: ...
    def __ne__(self, other: Literal) -> bool: ...

class Quad:
    @property
    def subject(self) -> Subject: ...
    @property
    def predicate(self) -> NamedNode: ...
    @property
    def object(self) -> Term: ...
    @property
    def graph_name(self) -> GraphName: ...
    @property
    def triple(self) -> Triple: ...
    def __init__(
        self,
        subject: Subject,
        predicate: NamedNode,
        object: Term,
        graph_name: Optional[GraphName] = None,
    ) -> None: ...
    def __eq__(self, other: Quad) -> bool: ...
    def __ge__(self, other: Quad) -> bool: ...
    def __getitem__(self, index: int) -> Union[Subject, NamedNode, Term, GraphName]: ...
    def __gt__(self, other: Quad) -> bool: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator: ...
    def __le__(self, other: Quad) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: Quad) -> bool: ...
    def __ne__(self, other: Quad) -> bool: ...

class QuerySolution:
    def __init__(self, *args, **kwargs) -> None: ...
    def __getitem__(self, index: int) -> Term: ...
    def __iter__(self) -> QuerySolution: ...
    def __next__(self) -> Term: ...
    def __len__(self) -> int: ...

class QuerySolutions:
    @property
    def variables(self) -> List[Variable]: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> QuerySolutions: ...
    def __next__(self) -> QuerySolution: ...

class QueryTriples:
    def __init__(self, *args, **kwargs) -> None: ...
    def __iter__(self) -> QueryTriples: ...
    def __next__(self) -> Triple: ...

class Store:
    def __init__(self, path: Optional[str] = None) -> None: ...
    def add(self, quad: Quad) -> None: ...
    def add_graph(self, graph_name: Union[NamedNode, BlankNode]) -> None: ...
    def backup(self, target_directory: str) -> None: ...
    def bulk_load(
        self,
        input: Union[io.RawIOBase, io.BufferedIOBase, str],
        mime_type: str,
        base_iri: Optional[str] = None,
        to_graph: Optional[GraphName] = None,
    ) -> Any: ...
    def clear(self) -> None: ...
    def clear_graph(self, graph_name: GraphName) -> None: ...
    def dump(
        self,
        output: Union[io.RawIOBase, io.BufferedIOBase, str],
        mime_type: str,
        from_graph: Optional[GraphName] = None,
    ) -> None: ...
    def flush(self) -> None: ...
    def load(
        self,
        input: Union[io.RawIOBase, io.BufferedIOBase, str],
        mime_type: str,
        base_iri: Optional[str] = None,
        to_graph: Optional[GraphName] = None,
    ) -> Any: ...
    def named_graphs(self) -> Iterator[Union[NamedNode, BlankNode]]: ...
    def optimize(self) -> None: ...
    def quads_for_pattern(
        self,
        subject: Optional[Subject] = None,
        predicate: Optional[NamedNode] = None,
        object: Optional[Term] = None,
        graph_name: Optional[GraphName] = None,
    ) -> Iterator[Quad]: ...
    def query(
        self,
        query: str,
        base_iri: Optional[str] = None,
        use_default_graph_as_union: bool = False,
        default_graph: Optional[
            Union[
                GraphName,
                List[GraphName],
            ]
        ] = None,
        named_graphs: Optional[List[NamedNode, BlankNode]] = None,
    ) -> Union[QuerySolutions, QueryTriples, bool]: ...
    def remove(self, quad: Quad) -> None: ...
    def remove_graph(self, graph_name: GraphName) -> None: ...
    def update(self, update: str, base_iri: Optional[str] = None) -> None: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, quad: Quad) -> bool: ...
    def __iter__(self) -> Iterator[Quad]: ...
    def __len__(self) -> int: ...

class Triple:
    @property
    def subject(self) -> Subject: ...
    @property
    def predicate(self) -> NamedNode: ...
    @property
    def object(self) -> Term: ...
    def __init__(
        self,
        subject: Subject,
        predicate: NamedNode,
        object: Term,
    ) -> None: ...
    def __eq__(self, other: Triple) -> bool: ...
    def __ge__(self, other: Triple) -> bool: ...
    def __getitem__(self, index: int) -> Term: ...
    def __gt__(self, other: Triple) -> bool: ...
    def __hash__(self) -> int: ...
    def __iter__(self) -> Iterator[Term]: ...
    def __le__(self, other: Triple) -> bool: ...
    def __len__(self) -> int: ...
    def __lt__(self, other: Triple) -> bool: ...
    def __ne__(self, other: Triple) -> bool: ...

class Variable:
    @property
    def value(self) -> str: ...
    def __init__(self, *args, **kwargs) -> None: ...
    def __eq__(self, other: Variable) -> bool: ...
    def __ge__(self, other: Variable) -> bool: ...
    def __gt__(self, other: Variable) -> bool: ...
    def __hash__(self) -> int: ...
    def __le__(self, other: Variable) -> bool: ...
    def __lt__(self, other: Variable) -> bool: ...
    def __ne__(self, other: Variable) -> bool: ...

def parse(
    input: Union[io.RawIOBase, io.BufferedIOBase, str],
    mime_type: str,
    base_iri: Optional[str] = None,
) -> Iterator[Union[Triple, Quad]]: ...
def serialize(
    input: Iterator[Union[Triple, Quad]],
    output: Union[io.RawIOBase, io.BufferedIOBase, str],
    mime_type: str,
) -> None: ...
